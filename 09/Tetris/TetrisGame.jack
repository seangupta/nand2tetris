/**
 * Represents a Tetris game.
 */
class TetrisGame {

    static TetrisGame instance; // A Tetris game
    static char direction_left, direction_right, direction_down, direction_fall, direction_rotate, direction_hard_drop;

    field boolean exit;       // true when the game is over     
    field int total_lines_cleared;

    field boolean move_left, move_right, move_down, rotate, hard_drop;

    field boolean block_done; // when the handling of the current block is finished

    field int key;
    field char direction;

    field Block current_block;

    field int line_width; // width of bounding lines
    field int fall_delay_ms; // Delay between falls
    
    // 20 x 10 array showing whether field is empty (= 0) or occupied(= 1)
    // Y x X as we want to iterate through rows to identify cleared lines
    field Map map;

    field Array hard_drop_coords_all, current_coords_all;
    field int drop_length;
    field boolean moved;

    /** Constructs a new Tetris game. */
    constructor TetrisGame new() {
        var String initial_lines_string, start_game_string, s, t, u, v, w, x;

        let s = "l";
        let direction_left = s.charAt(0);

        let t = "r";
        let direction_right = t.charAt(0);

        let u = "u";
        let direction_rotate = u.charAt(0);

        let v = "d";
        let direction_down = v.charAt(0);

        let w = "f";
        let direction_fall = w.charAt(0);

        let x = "h";
        let direction_hard_drop = x.charAt(0);

        do Memory.deAlloc(s);
        do Memory.deAlloc(t);
        do Memory.deAlloc(u);
        do Memory.deAlloc(v);
        do Memory.deAlloc(w);
        do Memory.deAlloc(x);

	    do Screen.clearScreen();
        let total_lines_cleared = 0;

        let line_width = 2;
        let fall_delay_ms = 300;

        let map = Map.initialise_map();

        do Screen.drawRectangle(196 - line_width, 16, 195, 255);
        do Screen.drawRectangle(316, 16, 315 + line_width, 255);

	    do Output.moveCursor(22,0);
        let initial_lines_string = "Lines cleared: 0";
	    do Output.printString(initial_lines_string);
        do Memory.deAlloc(initial_lines_string);

        let start_game_string = "Press Enter!";
        do Output.moveCursor(10, 26);
        do Output.printString(start_game_string);
        do Memory.deAlloc(start_game_string);

        let exit = false;

        return this;
    }

    method void dispose() {
        do map.dispose();
        do Memory.deAlloc(instance);
        do Memory.deAlloc(this);
        return;
    }

    function void newInstance() {
        let instance = TetrisGame.new();
        return;
    }
    
    function TetrisGame getInstance() {
        return instance;
    }

    method void update_hard_drop_coordinates(boolean first_cycle){
        var Array current_coords, coord, arr;
        var int i, this_square_drop_length, x, y, y_to_check, field_height;
        var boolean occupied;

        let field_height = map.get_field_height();
        let drop_length = 999;

        // get map heights per relevant column after excluding current block coordinates
        // compute min diff betwen map heights and square heights

        let i = 0;
        while (i < 4){
            let current_coords = current_coords_all[i];
            let x = current_coords[0];
            let y = current_coords[1];

            // check (x, y + 1) onwards
            let y_to_check = y + 1;
            let occupied = false;
            let this_square_drop_length = 0;
            while ((y_to_check < field_height) & (~occupied)){
                let coord = Array.new(2);
                let coord[0] = x;
                let coord[1] = y_to_check;
                if (~Utils.is_coord_in_coords(coord, current_coords_all)){
                    let occupied = map.get_map_coords(y_to_check, x);
                }
                if (~occupied){
                    let this_square_drop_length = this_square_drop_length + 1;
                }

                let y_to_check = y_to_check + 1;
                do Memory.deAlloc(coord);
            }
            let drop_length = Math.min(drop_length, this_square_drop_length);
            let i = i + 1;
        }

        if (~first_cycle) {
            do hide_hard_drop_preview();
            do Utils.dispose_coords(hard_drop_coords_all);
        }

        let hard_drop_coords_all = Array.new(4);
        let i = 0;
        while (i < 4){
            let current_coords = current_coords_all[i];

            let arr = Array.new(2);
            let arr[0] = current_coords[0];
            let arr[1] = current_coords[1] + drop_length;

            let hard_drop_coords_all[i] = arr;
            let i = i + 1;
        }

        do show_hard_drop_preview();
        return;
    }


    method void hide_hard_drop_preview() {
        var int i;
        var Square sq;
        var Array hard_drop_coords;

        let i = 0;
        while (i < 4) {
            let hard_drop_coords = hard_drop_coords_all[i];
            let sq = Square.new(hard_drop_coords[0], hard_drop_coords[1]);
            do sq.hide_preview();
            do sq.dispose();
            let i = i + 1;
        }
        return;
    }

    method void show_hard_drop_preview() {
        var int i;
        var Square sq;
        var Array hard_drop_coords;

        let i = 0;
        while (i < 4) {
            let hard_drop_coords = hard_drop_coords_all[i];
            let sq = Square.new(hard_drop_coords[0], hard_drop_coords[1]);
            do sq.show_preview();
            do sq.dispose();
            let i = i + 1;
        }
        return;
    }


    method boolean move_if_valid(Block current_block){
        var int i, x_new, y_new;
        var boolean occupied, can_move;
        var Array new_coords_all, new_coords, map_row;

        let new_coords_all = current_block.generate_post_move_coordinates(direction);

        let i = 0;
        let can_move = true;
        while (i < 4){
            let new_coords = new_coords_all[i];
            let x_new = new_coords[0];
            let y_new = new_coords[1];

            if (map.is_valid_x(x_new) & (map.is_valid_y(y_new))){
                if (~Utils.is_coord_in_coords(new_coords, current_coords_all)){
                    let map_row = map.get_map_row(y_new);
                    let occupied = map_row[x_new];
                    let can_move = can_move & (~(occupied));
                }
            }
            else {
                let can_move = false;
            }
            let i = i + 1;
        }
        
        if (can_move){
            do map.update(current_coords_all, false);
            do current_block.apply_move(new_coords_all, direction, 0);
            do map.update(new_coords_all, true);
            let moved = true;

            do Utils.dispose_coords(current_coords_all);
            let current_coords_all = current_block.get_coords();
        }

        do Utils.dispose_coords(new_coords_all);
        return can_move;
    }

    method void move_if_valid_hard_drop(Block current_block) {
        if (drop_length > 0){
            do map.update(current_coords_all, false);
            do current_block.apply_move(hard_drop_coords_all, direction, drop_length);
            do map.update(hard_drop_coords_all, true);

            let moved = true;
            do Utils.dispose_coords(current_coords_all);
            let current_coords_all = current_block.get_coords();
        }
        else {
            let exit = true;
        }

        let block_done = true;
        return;
    }

    method void key_to_action(int key) {
        if (key = 140){
            let exit = true;
            }
            else {
                if (key = 130){
                    let move_left = true;
                }
                else {
                    if (key = 132){
                        let move_right = true;
                    }
                    else {
                        if (key = 131){
                            let rotate = true;
                        }
                        else {
                            if (key = 133){
                                let move_down = true;
                            }
                            else {
                                if (key = 32){
                                    let hard_drop = true;
                                }
                            }
                        }
                    }
                }
            }
        return;
    }

    method void act_on_key() {
        let move_left = false;
        let move_right = false;
        let rotate = false;
        let move_down = false;
        let hard_drop = false;

        do key_to_action(key);

        if (move_left){
            let direction = direction_left;
            do move_if_valid(current_block);
        }
        else {
            if (move_right){
                let direction = direction_right;
                do move_if_valid(current_block);
            }
            else {
                if (rotate){
                    let direction = direction_rotate;
                    do move_if_valid(current_block);
                }
                else {
                    if (move_down){
                        let direction = direction_down;
                        do move_if_valid(current_block);
                    }
                    else {
                        if (hard_drop){
                            let direction = direction_hard_drop;
                            do move_if_valid_hard_drop(current_block);
                        }
                    }
                }
            }
        }

        return;
    }


    method void handle_current_block() {
        var int num_falls;
        var int num_lines_cleared;
        var int num_waits;
        var boolean key_was_released, first_cycle;

        let block_done = false;
        let num_falls = 0;
        let num_waits = 0;
        
        let move_left = false;
        let move_right = false;
        let rotate = false;
        let move_down = false;
        let hard_drop = false;

        let key_was_released = false;
        let first_cycle = true;

        // Only act on key press and release (cannot keep holding down key)

        let current_coords_all = current_block.get_coords();
        do update_hard_drop_coordinates(first_cycle);

        while ((~exit) & (~block_done)){
            let moved = false;

            let key = Keyboard.keyPressed();
            if (key = 0){
                let key_was_released = true;
                let hard_drop = false;
            }
            else {
                if (key_was_released){
                    do act_on_key();
                    do update_hard_drop_coordinates(first_cycle);
                }
                let key_was_released = false;
            }

            if (~hard_drop){
                if ((num_waits > 0) & (Utils.mod(num_waits, fall_delay_ms) = 0)) {
                    let direction = direction_fall;
                    let block_done = ~move_if_valid(current_block);
                    if ((num_falls = 0) & (block_done)){
                        let exit = true;
                    }
                    let num_falls = num_falls + 1;
                }
            }

            do Sys.wait(1);
            let num_waits = num_waits + 1;
            let first_cycle = false;
        }

        // fill white border black again
        do show_hard_drop_preview();

        let num_lines_cleared = map.potentially_clear_lines();
        let total_lines_cleared = total_lines_cleared + num_lines_cleared;

        if (num_lines_cleared > 0){
            do output_lines_cleared();
        }
        return;
    }


    /** Starts the game, and handles input from the user
    controlling the block's movements.
    */
    method void run() {
        var String erase_string, game_over_string;
        var boolean start_game;
        var int key, random_number, random_number_bucketed, random_seed;
        var Rng rng;

        let start_game = false;
        let random_seed = 0;

        while (~start_game) {
            let key = Keyboard.keyPressed();
            if (key = 128){
                let start_game = true;
            }
            let random_seed = random_seed + 1;
            do Sys.wait(1);
        }
        
        do Output.moveCursor(10, 26);
        let erase_string = "            ";
        do Output.printString(erase_string);
        do Memory.deAlloc(erase_string);

        let rng = Rng.new(random_seed);

        while (~exit) {
            let random_number = rng.next();
            let random_number_bucketed = rng.random_to_one_to_n(random_number, 7);
            if (random_number_bucketed = 0){
                let current_block = Block.new_block_i();
            }
            else {
                if (random_number_bucketed = 1){
                    let current_block = Block.new_block_o();
                }
                else {
                    if (random_number_bucketed = 2){
                        let current_block = Block.new_block_j();
                    }
                    else {
                        if (random_number_bucketed = 3){
                            let current_block = Block.new_block_l();
                        }
                        else {
                            if (random_number_bucketed = 4){
                                let current_block = Block.new_block_s();
                            }
                            else {
                                if (random_number_bucketed = 5){
                                    let current_block = Block.new_block_z();
                                }
                                else {
                                    if (random_number_bucketed = 6){
                                        let current_block = Block.new_block_t();
                                    }
                                    else {
                                        do Sys.halt();
                                    }
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
            }
            
            do current_block.show();
            do handle_current_block();
            do current_block.dispose();
        }

        if (exit) {
            do Output.moveCursor(10, 27);
            let game_over_string = "Game Over!";
            do Output.printString(game_over_string);
            do Memory.deAlloc(game_over_string);
        }

    return;
    }


    method void output_lines_cleared() {
        do Output.moveCursor(22,15);
        do Output.printInt(total_lines_cleared);
        return;
    }

}