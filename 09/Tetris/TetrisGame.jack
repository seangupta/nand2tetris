/**
 * Represents a Tetris game.
 */
class TetrisGame {

    static TetrisGame instance; // A Tetris game
    static char direction_left, direction_right, direction_up, direction_down, direction_fall;

    field boolean exit;       // true when the game is over     
    field int num_lines_cleared; // current number of lines num_lines_cleared

    field boolean move_left, move_right, rotate_up, rotate_down;

    field boolean block_done; // when the handling of the current block is finished

    field int key;
    field char direction;

    field IBlock current_block;

    field int line_width; // width of bounding lines
    field int move_delay_ms; // Delay between moves
    
    // 20 x 10 array showing whether field is empty (= 0) or occupied(= 1)
    // Y x X as we want to iterate through rows to identify cleared lines
    field Map map;

    field String s, t, u, v, w;

    /** Constructs a new Tetris game. */
    constructor TetrisGame new() {

        let s = "l";
        let direction_left = s.charAt(0);

        let t = "r";
        let direction_right = t.charAt(0);

        let u = "u";
        let direction_up = u.charAt(0);

        let v = "d";
        let direction_down = v.charAt(0);

        let w = "f";
        let direction_fall = w.charAt(0);

	    do Screen.clearScreen();
        let num_lines_cleared = 0;

        let line_width = 2;
        let move_delay_ms = 200;

        let map = Map.initialise_map();

        do Screen.drawRectangle(196 - line_width, 16, 195, 255);
        do Screen.drawRectangle(316, 16, 315 + line_width, 255);

	    do Output.moveCursor(22,0);
	    do Output.printString("Lines cleared: 0");

        let exit = false;
	    let num_lines_cleared = 0;

        return this;
    }

    /** Deallocates the object's memory. */
    method void dispose() {
        do Memory.deAlloc(current_block);
        do map.dispose();

        do Memory.deAlloc(s);
        do Memory.deAlloc(t);
        do Memory.deAlloc(u);
        do Memory.deAlloc(v);
        do Memory.deAlloc(w);

        do Memory.deAlloc(instance);
        do Memory.deAlloc(this);
        return;
    }

    /** Creates an instance of a Tetris game. */
    function void newInstance() {
        let instance = TetrisGame.new();
        return;
    }
    
    /** Returns this Tetris game. */
    function TetrisGame getInstance() {
        return instance;
    }

    method boolean move_if_valid(IBlock current_block){
        var int i, x_new, y_new;
        var boolean occupied, can_move;
        var Array old_coords_all, new_coords_all, new_coords, map_row;

        let old_coords_all = current_block.get_coords();
        let new_coords_all = current_block.generate_post_move_coordinates(direction);

        let i = 0;
        let can_move = true;
        while (i < 4){
            let new_coords = new_coords_all[i];
            let x_new = new_coords[0];
            let y_new = new_coords[1];

            if (map.is_valid_x(x_new) & (map.is_valid_y(y_new))){
                if (~Utils.is_coord_in_coords(new_coords, old_coords_all)){
                    let map_row = map.get_map_row(y_new);
                    let occupied = map_row[x_new];
                    let can_move = can_move & (~(occupied));
                }
            }
            else {
                let can_move = false;
            }
            let i = i + 1;
        }
        
        if (can_move){
            do map.update(old_coords_all, false);
            do current_block.apply_move(new_coords_all, direction);
            do map.update(new_coords_all, true);
        }

        let i = 0;
        while (i < 4){
            do Memory.deAlloc(old_coords_all[i]);
            let i = i + 1;
        }
        do Memory.deAlloc(old_coords_all);

        let i = 0;
        while (i < 4){
            do Memory.deAlloc(new_coords_all[i]);
            let i = i + 1;
        }
        do Memory.deAlloc(new_coords_all);

        return can_move;
    }

    method void key_to_action(int key) {
        if (key = 140){
            let exit = true;
            }
            else {
                if (key = 130){
                    let move_left = true;
                }
                else {
                    if (key = 132){
                        let move_right = true;
                    }
                    else {
                        if (key = 131){
                            let rotate_up = true;
                        }
                        else {
                            if (key = 133){
                                let rotate_down = true;
                            }
                        }
                    }
                }
            }
        return;
    }


    /** Starts the game, and handles input from the user
    controlling the block's movements.
    */
    method void run() {
        while (~exit) {
            let current_block = IBlock.new(5, -2);
            do current_block.show();
            do handle_current_block();
            do current_block.dispose();
        }

        if (exit) {
            do Output.moveCursor(10,27);
            do Output.printString("Game Over");
        }

    return;
    }

    method void handle_current_block() {
        var int i;

        let block_done = false;
        let i = 0;

        while (~block_done){
        
            let move_left = false;
            let move_right = false;
            let rotate_up = false;
            let rotate_down = false;

            // Waits for a key to be pressed
            while ((key = 0) & (~exit) & (~block_done)){
                let key = Keyboard.keyPressed();
                let direction = direction_fall;
                let block_done = ~move_if_valid(current_block);
                if ((i = 0) & (block_done)){
                    let exit = true;
                }
                let i = i + 1;
                do Sys.wait(move_delay_ms);
            }

            do key_to_action(key);

            // Waits for the key to be released
            while ((~(key = 0)) & (~exit) & (~block_done)){
                let key = Keyboard.keyPressed();
                if (move_left){
                    let direction = direction_left;
                    do move_if_valid(current_block);
                }
                else {
                    if (move_right){
                        let direction = direction_right;
                        do move_if_valid(current_block);
                    }
                    else {
                        if (rotate_up){
                            let direction = direction_up;
                            do move_if_valid(current_block);
                        }
                        else {
                            if (rotate_down){
                                let direction = direction_down;
                                do move_if_valid(current_block);
                            }
                        }
                    }
                }
                let direction = direction_fall;
                let block_done = ~move_if_valid(current_block);
                if ((i = 0) & (block_done)){
                    let exit = true;
                }
                let i = i + 1;
                do Sys.wait(move_delay_ms);
            }
        }

        do map.potentially_clear_lines();
        return;
    }

}