/** Represents a block. */

class Block {
    static char direction_left, direction_right, direction_down, direction_fall, direction_rotate, direction_hard_drop;

    field Array squares; // individual component squares (length 4)
    field int rotation; // 0-3 (starts at 0) 

    field Array rotation_zero_offsets, rotation_one_offsets, rotation_two_offsets, rotation_three_offsets;
    field Array rotation_offsets_all;

    field int bb_x, bb_y;

    field String s, t, u, v, w, x;

    method void initialise() {
        let s = "l";
        let direction_left = s.charAt(0);

        let t = "r";
        let direction_right = t.charAt(0);

        let u = "u";
        let direction_rotate = u.charAt(0);

        let v = "d";
        let direction_down = v.charAt(0);

        let w = "f";
        let direction_fall = w.charAt(0);

        let x = "h";
        let direction_hard_drop = x.charAt(0);

        do Memory.deAlloc(s);
        do Memory.deAlloc(t);
        do Memory.deAlloc(u);
        do Memory.deAlloc(v);
        do Memory.deAlloc(w);
        do Memory.deAlloc(x);
        
        let rotation = 0;
        return;
    }


    method void create_squares() {
        var int i;
        var Array coords;

        let squares = Array.new(4);
        let i = 0;
        while (i < 4){
            let coords = rotation_zero_offsets[i];
            let squares[i] = Square.new(coords[0], coords[1]);
            let i = i + 1;
        }

        return;
    }

    constructor Block new_block_i(int Ax, int Ay) {
        // Ax: x coordinate (within Tetris field) of top left bounding box square
        // Ay: y coordinate (within Tetris field) of top left bounding box square

        let rotation_zero_offsets = Utils.create_offsets_list(0, 2, 1, 2, 2, 2, 3, 2);
        let rotation_one_offsets = Utils.create_offsets_list(2, 0, 2, 1, 2, 2, 2, 3);
        let rotation_two_offsets = Utils.create_offsets_list(0, 2, 1, 2, 2, 2, 3, 2);
        let rotation_three_offsets = Utils.create_offsets_list(2, 0, 2, 1, 2, 2, 2, 3);

        let rotation_offsets_all = Array.new(4);
        let rotation_offsets_all[0] = rotation_zero_offsets;
        let rotation_offsets_all[1] = rotation_one_offsets;
        let rotation_offsets_all[2] = rotation_two_offsets;
        let rotation_offsets_all[3] = rotation_three_offsets;

        do initialise();

        let bb_x = Ax;
        let bb_y = Ay;

        do create_squares();

        do show();
        return this;
    }

    constructor Block new_block_o(int Ax, int Ay) {
        // Ax: x coordinate (within Tetris field) of top left bounding box square
        // Ay: y coordinate (within Tetris field) of top left bounding box square

        let rotation_zero_offsets = Utils.create_offsets_list(1, 1, 1, 2, 2, 1, 2, 2);
        let rotation_one_offsets = Utils.create_offsets_list(1, 1, 1, 2, 2, 1, 2, 2);
        let rotation_two_offsets = Utils.create_offsets_list(1, 1, 1, 2, 2, 1, 2, 2);
        let rotation_three_offsets = Utils.create_offsets_list(1, 1, 1, 2, 2, 1, 2, 2);

        let rotation_offsets_all = Array.new(4);
        let rotation_offsets_all[0] = rotation_zero_offsets;
        let rotation_offsets_all[1] = rotation_one_offsets;
        let rotation_offsets_all[2] = rotation_two_offsets;
        let rotation_offsets_all[3] = rotation_three_offsets;

        do initialise();

        let bb_x = Ax;
        let bb_y = Ay;

        do create_squares();

        do show();
        return this;
    }


    constructor Block new_block_j(int Ax, int Ay) {
        // Ax: x coordinate (within Tetris field) of top left bounding box square
        // Ay: y coordinate (within Tetris field) of top left bounding box square

        let rotation_zero_offsets = Utils.create_offsets_list(0, 1, 1, 1, 2, 1, 2, 2);
        let rotation_one_offsets = Utils.create_offsets_list(1, 0, 1, 1, 0, 2, 1, 2);
        let rotation_two_offsets = Utils.create_offsets_list(0, 0, 0, 1, 1, 1, 2, 1);
        let rotation_three_offsets = Utils.create_offsets_list(1, 0, 2, 0, 1, 1, 1, 2);

        let rotation_offsets_all = Array.new(4);
        let rotation_offsets_all[0] = rotation_zero_offsets;
        let rotation_offsets_all[1] = rotation_one_offsets;
        let rotation_offsets_all[2] = rotation_two_offsets;
        let rotation_offsets_all[3] = rotation_three_offsets;

        do initialise();

        let bb_x = Ax;
        let bb_y = Ay;

        do create_squares();

        do show();
        return this;
    }



    method void dispose() {
        var int i;
        var Square sq;

        let i = 0;
        while (i < 4){
            let sq = squares[i];
            do sq.dispose();
            let i = i + 1;
        }

        do Memory.deAlloc(squares);

        do Memory.deAlloc(rotation_zero_offsets);
        do Memory.deAlloc(rotation_one_offsets);
        do Memory.deAlloc(rotation_two_offsets);
        do Memory.deAlloc(rotation_three_offsets);

        do Memory.deAlloc(rotation_offsets_all);

        do Memory.deAlloc(this);
        return;
    }

    method void show() {
        do Screen.setColor(true);
        do draw();
        return;
    }

    method void hide() {
        do Screen.setColor(false);
        do draw();
        return;
    }

    method void draw() {
        var int i;
        var Square sq;
        
        let i = 0;
        while (i < 4) {
            let sq = squares[i];
            do sq.draw();
            let i = i + 1;
        }

        return;
    }

    method Array get_coords(){
        var Array coords_all, arr;
        var int i;
        var Square sq;

        let coords_all = Array.new(4);
        let i = 0;
        while (i < 4){
            let sq = squares[i];
            let arr = Array.new(2);
            let arr[0] = sq.get_x();
            let arr[1] = sq.get_y();
            let coords_all[i] = arr;
            let i = i + 1;
        }
        return coords_all;
    }

    method Array generate_post_move_coordinates(char direction){
        var Array new_coords_all, move_offsets, arr, move_offset, bb_offset;
        var int i, post_move_rotation, bb_x_new, bb_y_new;

        let bb_offset = Array.new(2);
        let bb_offset[0] = 0;
        let bb_offset[1] = 0;
        
        let post_move_rotation = rotation;

        if (direction = direction_left){
            let bb_offset[0] = -1;
        }
        else {
            if (direction = direction_right){
                let bb_offset[0] = 1;
            }
            else {
                if (direction = direction_fall){
                    let bb_offset[1] = 1;   
                }
                else {
                    if (direction = direction_rotate){
                        let post_move_rotation = Utils.mod(rotation + 1, 4);
                    }
                    else {
                        if (direction = direction_down) {
                            let bb_offset[1] = 1;
                        }
                    }
                }
            }
        }

        if (post_move_rotation < 0){
            do Sys.halt();
        }

        let move_offsets = rotation_offsets_all[post_move_rotation];

        let new_coords_all = Array.new(4);

        let bb_x_new = bb_x + bb_offset[0];
        let bb_y_new = bb_y + bb_offset[1];

        let i = 0;
        while (i < 4){
            let move_offset = move_offsets[i];
            let arr = Array.new(2);
            let arr[0] = bb_x_new + move_offset[0];
            let arr[1] = bb_y_new + move_offset[1];
            let new_coords_all[i] = arr;
            let i = i + 1;
        }
        do Memory.deAlloc(bb_offset);
        return new_coords_all;
    }

    method void apply_move(Array new_coords_all, char direction, int drop_length){
        var int i, x_y_new;
        var Square sq;

        do hide();

        let i = 0;
        while (i < 4){
            let x_y_new = new_coords_all[i];

            do Memory.deAlloc(squares[i]);
            let sq = Square.new(x_y_new[0], x_y_new[1]);
            let squares[i] = sq;
            let i = i + 1;
        }

        if (direction = direction_left){
            let bb_x = bb_x - 1;
        }
        else {
            if (direction = direction_right){
                let bb_x = bb_x + 1;
            }
            else {
                if ((direction = direction_fall) | (direction = direction_down)){
                    let bb_y = bb_y + 1;
                }
                else {
                    if (direction = direction_rotate){
                        let rotation = Utils.mod(rotation + 1, 4);
                    }
                    else {
                        if (direction = direction_hard_drop){
                            let bb_y = bb_y + drop_length;
                        }
                    }
                }
            }
        }

        do show();
        return;
    }
}